import cv2
import multiresolutionimageinterface as mir
from multiresolutionimageinterface import MultiResolutionImageWriter as TileWriter
import numpy as np
import time
import matplotlib.pyplot as plt
from annotationmanager import AnnotationType
from PySide2 import QtCore, QtWidgets
from PySide2.QtCore import Signal, Slot
from PySide2.QtCore import QThread
from ui_dialogprocess import ProcessDialog
import multiprocessing


class MaskWriter(TileWriter):

    SignalProgress = Signal(float)

    def __init__(self, compression=mir.RAW, qualityJpeg=70):

        super(MaskWriter, self).__init__()
        self.setDataType(mir.UChar)
        self.setCompression(compression)
        if compression == mir.JPEG:
            self.setJPEGQuality(qualityJpeg) # this parameter won't infect the quality of JPEG2000
        self.processThread = ProcessThread(self)

    def writeMask(self, manager, pathExport: str, channels: int=1):

        processDialog = ProcessDialog(manager.mainwindow)
        processDialog.show()
        # multi-processing
        self.processThread.manager = manager
        self.processThread.pathExport = pathExport
        self.processThread.channels = channels
        self.processThread.SignalProcess.connect(processDialog.slot_set_value_comments)
        self.processThread.finished.connect(processDialog.close)
        self.processThread.start()


class ProcessThread(QThread):

    SignalProcess = Signal(list)

    def __init__(self, writer: MaskWriter, parent:QtWidgets.QWidget=None):

        if parent is None:
            super(ProcessThread, self).__init__()
        elif isinstance(parent, QtWidgets.QWidget):
            super(ProcessThread, self).__init__(parent)
        self.writer = writer
        self.manager = None
        self.pathExport = ''
        self.channels = 1

    def run(self):

        if self.channels == 1:
            self.writer.setColorType(mir.Monochrome)
        elif self.channels == 3:
            self.writer.setColorType(mir.RGB)
        elif self.channels == 4:
            self.writer.setColorType(mir.ARGB)
        self.writer.setTileSize(self.manager.widthTile)
        self.writer.openFile(self.pathExport)
        self.writer.writeImageInformation(self.manager.widthImage, self.manager.heightImage)
        time_start = time.time()
        for v in range(self.manager.numTileY):
            for h in range(self.manager.numTileX):
                print("processing: {} {}".format(v, h))
                base = np.zeros((self.manager.heightTile, self.manager.widthTile, self.channels), dtype=np.uint8)
                data = self.manager.getTileAnnotation((h, v))
                if len(data) > 0:
                    for nameCategory, contentCategory in data.items():
                        type = self.manager.getCategoryType(nameCategory)
                        if type == AnnotationType.Dot or type == "Dot":
                            pass
                        elif type == AnnotationType.Rect or type == "Rectangle":
                            for indexGroup, contentGroup in contentCategory.items():
                                for rectange in contentGroup:
                                    rectange = [int(i) for i in rectange]
                                    cv2.rectangle(base, tuple(rectange),
                                                  self.manager.categoriesInfo[nameCategory][3], -1)
                        elif type == AnnotationType.Polygon or type == "Polygon":
                            for indexGroup, contentGroup in contentCategory.items():
                                cv2.drawContours(base, np.array([contentGroup], dtype=np.int),
                                                 -1, color=self.manager.categoriesInfo[nameCategory][3], thickness=-1)
                self.writer.writeBaseImagePartToLocation(base.astype(np.uint8).flatten(), h * self.manager.widthTile, v * self.manager.heightTile)
            time_now = time.time()
            time_used = time_now - time_start
            self.SignalProcess.emit([(v + 1) / self.manager.numTileY * 99, time_used])
            print((v + 1) / self.manager.numTileY * 99)
        self.sleep(1)
        self.writer.finishImage()
        # self.finished.emit()
        print("write done")


if __name__ == '__main__':

    from annotationmanager import TileAnnotationManager
    dic = TileAnnotationManager("abc", 0, 2048, 2048, 1024, 1024)
    dic.addCategory("Normal", [255, 0, 0, 0], 0, AnnotationType.Rect, 255)
    dic.addGroup("Normal")
    dic.addPoints("Normal", 0, (0, 0), (1000, 1000), (100, 100, 900, 900))
    print("content: ", dic.getTileAnnotation((0, 0)))

    writer = MaskWriter(mir.JPEG, 95)
    writer.writeMask(dic, "F:\\Lab\\cbd.tiff", 1)

    # can read the .tiff file generated by writer by imageio, which will make a specified format file,
    # we can use numpy to change format


